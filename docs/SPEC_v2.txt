# All numbers must be encoded in big-endian order

# Variable-length unsigned integers in big-endian order
varint ::=
    | (0b00 << 6) bit*6        # 0..(2^6  - 1) 0-63
    | (0b01 << 6) bit*6 byte   # 0..(2^14 - 1) 0-16383
    | (0b10 << 6) bit*6 byte*3 # 0..(2^30 - 1) 0-1073741823
    | (0b11 << 6) bit*6 byte*7 # 0..(2^62 - 1) 0-4611686018427387903

# traffic_frame is the top-level frame that encapsulates all SDP data

traffic_frame ::=
    masked_header
    traffic_flags  # 1 B
    connection_id? # optional varint, present if is_connection
    stream_frame+

# The frame must start with a packet number that uniquely identifies this frame
# for a given connection ID. If no connection ID is present, the packet number
# must be unique for all other non-connection frames

# If is_connection is set, masked_header is masked using an encrypted sample of
# stream_frame ciphertext

masked_header ::=
    packet_number        # varint
    masked_traffic_flags # 0 B, placeholder

masked_traffic_flags ::=
    | is_datagram  # 1 bit

# If is_connection is set, a connection_id is present, masked_header is masked,
# and stream_frame data is encrypted

traffic_flags ::=
    | is_connection # 1 << 6
    | phase         # 1 << 5

----------------------------------------------------------------

stream_frame ::=
    | stream_data_frame
    | stream_message_frame

# Ordered, reliable byte streams
stream_data_frame ::=
    data_frame_type # 1 B
    stream_id?      # optional varint, present if is_connection
    offset          # varint
    length?         # optional varint, present if not only frame in traffic frame
    byte+

data_frame_type ::=
    | data_frame
    | end_of_stream_frame

----------------------------------------------------------------

# Unordered, optionally reliable message streams
stream_message_frame ::=
    message_frame_type # 1 B
    stream_id?         # optional varint, present if is_connection
    message_id?        # optional varint, present if large_message_frame
    offset?            # optional varint, present if large_message_frame
    length?            # optional varint, present if not only frame in traffic frame
    byte+

message_frame_type ::=
    | large_message_frame # fragmented message
    | small_message_frame # unfragmented message
    | datagram_frame      # small message, force single datagram

----------------------------------------------------------------

handshake_packet ::=
    | connect_packet  # sender initiates handshake
    | identity_packet # sender identity
    | accept_packet   # receiver accepts handshake
    | reject_packet   # sender or receiver rejects handshake

~

Feels like different stream frames are the same kind of thing with different
"modes"

fragmented | ordered | reliable | type
           |         |          | unreliable datagram
           |         |        y | reliable datagram
           |       y |          | x (will wait forever)
           |       y |        y | datagram stream
         y |         |          | x (same as unreliable datagram)
         y |         |        y | x (same as reliable datagram)
         y |       y |          | x (will wait forever)
         y |       y |        y | byte stream | message stream

datagram_frame_type ::=
    | ordered
    | unordered_reliable
    | unreliable

datagram
  reliable
    ordered   0b000
    unordered 0b001
  unreliable  0b010

stream        0b011
  byte        0b100
  message     0b101

Ok that's a little more fleshed out, but feels like there is overlap between
stream_datagram_frame and stream_message_frame
