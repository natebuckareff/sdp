# All numbers must be encoded in big-endian order

# Variable-length unsigned integers in big-endian order
varint ::=
    | (0b00 << 6) bit*6        # 0..(2^6  - 1) 0-63
    | (0b01 << 6) bit*6 byte   # 0..(2^14 - 1) 0-16383
    | (0b10 << 6) bit*6 byte*3 # 0..(2^30 - 1) 0-1073741823
    | (0b11 << 6) bit*6 byte*7 # 0..(2^62 - 1) 0-4611686018427387903

# traffic_frame is the top-level frame that encapsulates all SDP data

traffic_frame ::=
    masked_header
    traffic_flags  # 1 B
    connection_id? # optional varint, present if is_connection
    stream_frame+

# The frame must start with a packet number that uniquely identifies this frame
# for a given connection ID. If no connection ID is present, the packet number
# must be unique for all other non-connection frames

# If is_connection is set, masked_header is masked using an encrypted sample of
# stream_frame ciphertext

masked_header ::=
    packet_number        # varint
    masked_traffic_flags

masked_traffic_flags ::=
    | is_datagram  # 1 bit

# If is_connection is set, a connection_id is present, masked_header is masked,
# and stream_frame data is encrypted

traffic_flags ::=
    | is_connection # 1 << 6
    | phase         # 1 << 5

----------------------------------------------------------------

stream_frame ::=
    | stream_data_frame
    | stream_message_frame

# Ordered, reliable byte streams
stream_data_frame ::=
    stream_data_type  # 4 bits
    stream_data_flags # 4 bits
    stream_id?        # optional varint, present if is_connection
    offset            # varint
    length?           # optional varint, present if not is_last_frame
    byte+

stream_data_type ::=
    | data_frame
    | end_of_stream_frame

stream_data_flags ::=
    | is_last_frame

----------------------------------------------------------------

# Unordered, optionally reliable message streams
stream_message_frame ::=
    stream_message_type  # 4 bits
    stream_message_flags # 4 bits
    stream_id?           # optional varint, present if is_connection
    message_id?          # optional varint, present if is_multi_frame
    offset               # varint
    length?              # optional varint, present if not is_last_frame
    byte+

stream_message_flags ::=
    | is_last_frame
    | is_multi_frame

----------------------------------------------------------------

handshake_packet ::=
    | connect_packet  # sender initiates handshake
    | identity_packet # sender identity
    | accept_packet   # receiver accepts handshake
    | reject_packet   # sender or receiver rejects handshake
